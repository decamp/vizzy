/*
 * Copyright (c) 2014. Massachusetts Institute of Technology
 * Released under the BSD 2-Clause License
 * http://opensource.org/licenses/BSD-2-Clause
 */

package bits.vizzy.input;

import bits.draw3d.DrawEnv;
import bits.draw3d.DrawNodeAdapter;
import bits.draw3d.actors.Actor;
import bits.draw3d.actors.MoveMode;
import bits.hidpunk.*;
import bits.hidpunk.spacenavigator.*;
import bits.math3d.Vec;
import bits.math3d.Vec3;
import bits.microtime.Clock;
import bits.util.event.EventSource;


/**
 * @author Philip DeCamp
 */
public class SpaceMouseController extends DrawNodeAdapter implements EventSource<SpaceNavigatorListener> {
    
    //Largest absolute value generated by space mouse.
    private static final float MAX_RAW_VALUE = 350;
    
    private static final int BUTTON_MODE_OFF         = 0;
    private static final int BUTTON_MODE_SENSITIVITY = 1;
    
    private static final float NOVICE_MODE_SENSITIVITY = 0.5f;
    private static final float EXPERT_MODE_SENSITIVITY = 1.0f;
    
    private final Clock mClock;
    private final VelocityActor mActor;
    private final SpaceNavigatorGroup mGroup;
    private final SpaceMouseHandler mSpaceHandler;
    
    private int     mButtonMode   = BUTTON_MODE_SENSITIVITY;
    private float   mMoveSpeed    = 1;
    private float   mRotateSpeed  = (float)( 0.8 * Math.PI );
    private float   mDeadZone     = 16.0f / 350.0f;
    private float   mSpeedMult    = 1.0f / MAX_RAW_VALUE;
    private boolean mNoviceMode  = false; 
    
    private long mStartMicros    = Long.MAX_VALUE;
    
        
    public SpaceMouseController( Clock clock, VelocityActor actor ) {
        mClock        = clock == null ? Clock.SYSTEM_CLOCK : clock;
        mActor        = actor == null ? new VelocityActor() : actor;
        mSpaceHandler = new SpaceMouseHandler();
        
        SpaceNavigatorGroup group = null;
        
        try {
            group = SpaceNavigatorGroup.create();
            group.addListener( mSpaceHandler );
        } catch( HidException ex ) {
            System.err.println( "HID Punk Not available:" );
            ex.printStackTrace();
            System.exit( -1 );
        }
        
        mGroup = group;
    }

    
    
    public Actor getActor() {
        return mActor;
    }

    
    public void moveSpeed( float speed ) {
        mMoveSpeed = speed;
    }
    
    
    public float moveSpeed() {
        return mMoveSpeed;
    }

    
    public void rotateSpeed( float maxRadsPerSecond ) {
        mRotateSpeed = maxRadsPerSecond;
    }
    
    
    public float rotateSpeed() {
        return mRotateSpeed;
    }
    
    
    public boolean noviceMode() {
        return mNoviceMode;
    }
    
    
    public synchronized void noviceMode( boolean mode ) {
        if( mNoviceMode == mode ) {
            return;
        }
        mNoviceMode = mode;
        if( mode ) {
            mActor.rollLock( true );
            mSpeedMult = NOVICE_MODE_SENSITIVITY / MAX_RAW_VALUE;
        } else {
            mActor.rollLock( false );
            mSpeedMult = EXPERT_MODE_SENSITIVITY / MAX_RAW_VALUE;
        }
    }

    
    public void incrementMoveSpeed() {
        moveSpeed( moveSpeed() * 1.1f );
    }
    
    
    public void decrementMoveSpeed() {
        moveSpeed( moveSpeed() / 1.1f );
    }
    
    
    public void incrementRotateSpeed() {
        rotateSpeed( rotateSpeed() * 1.1f );
    }
    
    
    public void decrementRotateSpeed() {
        rotateSpeed( rotateSpeed() / 1.1f );
    }
    

    public void buttonsControlSensitivity( boolean controlSensitivity ) {
        mButtonMode = controlSensitivity ? BUTTON_MODE_SENSITIVITY : BUTTON_MODE_OFF;
    }

    
    @Override
    public void init( DrawEnv d ) {
        if( mGroup != null ) {
            try {
                mGroup.start();
            } catch( HidException ex ) {}
        }
    }

    @Override
    public void pushDraw( DrawEnv d ) {
        long now = mClock.micros();
        
        if( now < mStartMicros ) {
            mActor.resetTime( 0.0 );
            mStartMicros = now;
        } else {
            mActor.updateTime( ( now - mStartMicros ) / 1000000.0 );
        }
    }

    
    
    public void addListener( SpaceNavigatorListener listener ) {
        mGroup.addListener( listener );
    }
    
    
    public void removeListener( SpaceNavigatorListener listener ) {
        mGroup.removeListener( listener );
    }

    
    private final class SpaceMouseHandler implements SpaceNavigatorListener {

        Vec3 mVelocity = new Vec3( 0, 0, 0 );
        Vec3 mRotation = new Vec3( 0, 0, 0 );
        
        float mX;
        float mY;
        float mZ;
        float mRX;
        float mRY;
        float mRZ;

        boolean mTranslating = false;
        boolean mRotating    = false;

        public void spaceButtonUp( int id ) {}

        public void spaceButtonDown( int id ) {
            if(mButtonMode != BUTTON_MODE_SENSITIVITY)
                return;
            
            switch(id) {
            case 1:
                if(!mNoviceMode) {
                    noviceMode(true);
                }else{
                    decrementMoveSpeed();
                    decrementRotateSpeed();
                }
                
                break;
                
            case 2:
                if(mNoviceMode) {
                    noviceMode(false);
                }else{
                    incrementMoveSpeed();
                    incrementRotateSpeed();
                }
                
                break;
            }
        }

        public void spacePuckMoved( int x, int y, int z, int rx, int ry, int rz ) {
            mX  = -y;
            mY  = -x;
            mZ  = -z;
            mRX = -ry;
            mRY = -rx;
            mRZ = -rz;
            
            float tranSum = Math.abs( mX ) + Math.abs( mY ) + Math.abs( mZ );
            float  rotSum;
            boolean repaint  = false;
            
            if(! mNoviceMode ) {
                rotSum = Math.abs( mRX ) + Math.abs( mRY ) + Math.abs( mRZ );
            } else {
                mRX *= 0.75f;
                float xx = Math.abs( mRX );
                float yy = Math.abs( mRY );
                float zz = Math.abs( mRZ );
                
                if(xx >= yy && xx >= zz) {
                    mRY    = 0;
                    mRZ    = 0;
                    rotSum = xx;
                }else if(yy >= xx && yy >= zz) {
                    mRX    = 0;
                    mRZ    = 0;
                    rotSum = yy;
                }else{
                    mRX    = 0;
                    mRY    = 0;
                    rotSum = zz;
                }
                if( tranSum > rotSum ) {
                    rotSum = 0;
                }else{
                    tranSum = 0;
                }
            }
            
            
            if( tranSum > mDeadZone * MAX_RAW_VALUE ) {
                Vec3 v = mVelocity;
                float scale = mMoveSpeed * mSpeedMult;
                v.x = mX * scale;
                v.y = mY * scale;
                v.z = mZ * scale;

                Vec.put( v, mActor.mMoveVel );
                mTranslating = true;
                repaint      = true;

            } else if( mTranslating ) {
                Vec3 v = mVelocity;
                v.x = 0;
                v.y = 0;
                v.z = 0;

                Vec.put( v, mActor.mMoveVel );
                mTranslating = false;
                repaint      = true;
            }

            if( rotSum > mDeadZone * MAX_RAW_VALUE ) {
                Vec3 r  = mRotation;
                float scale = mRotateSpeed * mSpeedMult;
                r.x = mRX * scale;
                r.y = mRY * scale;
                r.z = mRZ * scale;
                
                mActor.moveMode( MoveMode.FLY );
                Vec.put( r, mActor.mAngVel );
                mActor.rollLock( mNoviceMode );
                mRotating = true;
                repaint   = true;
                
            } else if( mRotating ) {
                Vec3 r = mRotation;
                r.x = 0;
                r.y = 0;
                r.z = 0;

                Vec.put( r, mActor.mAngVel );
                mRotating = false;
                repaint   = true;
            }

            if( repaint ) {
                triggerDisplay();
            }
        }

    }

    
    private void triggerDisplay() {}

}
